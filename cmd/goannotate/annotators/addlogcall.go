package annotators

import (
	"context"
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"cloudeng.io/errors"
	"cloudeng.io/go/annotations"
	"cloudeng.io/go/locate"
	"cloudeng.io/go/locate/locateutil"
	"cloudeng.io/text/edit"
	"golang.org/x/tools/go/packages"
	"gopkg.in/yaml.v2"
)

// AddLogCall represents an annotator for adding a function call that logs
// the entry and exit to every function and method that is matched by the
// locator.
type AddLogCall struct {
	Type                 string
	Interfaces           []string
	Functions            []string
	ContextType          string `yaml:"contextType"`
	Import               string
	Function             string
	IgnoreEmptyFunctions bool `yaml:"ignoreEmptyFunctions"`
	Concurrency          int

	// Used for templates.
	Name         string
	Tag          string
	ContextParam string
	Location     string
	Params       string
	Results      string
	Date         string
}

func init() {
	Register(&AddLogCall{})
}

func (lc *AddLogCall) Unmarshal(buf []byte) error {
	return yaml.Unmarshal(buf, lc)
}

func (lc *AddLogCall) Describe() string {
	return "logcall:\n"
}

func (lc *AddLogCall) Do(ctx context.Context, pkgs []string) error {
	locator := locate.New(
		concurrencyOpt(lc.Concurrency),
		locate.Trace(Verbosef),
		locate.IgnoreMissingFuctionsEtc(),
	)
	locator.AddInterfaces(lc.Interfaces...)
	locator.AddFunctions(lc.Functions...)
	locator.AddPackages(pkgs...)
	Verbosef("locating functions to be annotated...")
	if err := locator.Do(ctx); err != nil {
		return fmt.Errorf("failed to locate functions and/or interface implementations: %v\n", err)
	}

	dirty := map[string]bool{}
	edits := map[string][]edit.Delta{}
	errs := &errors.M{}
	locator.WalkFunctions(func(fullname string,
		pkg *packages.Package,
		file *ast.File,
		fn *types.Func,
		decl *ast.FuncDecl,
		implements []string) {
		if lc.IgnoreEmptyFunctions && isEmpty(decl) {
			return
		}
		invovation, comment, err := lc.annotationForFunc(pkg.Fset, fn, decl)
		if err != nil {
			errs.Append(err)
			return
		}
		if lc.alreadyAnnotated(pkg.Fset, file, fn, decl, comment) {
			Verbosef("%v: already annotated\n", fullname)
			return
		}
		lbrace := pkg.Fset.PositionFor(decl.Body.Lbrace, false)
		delta := edit.InsertString(lbrace.Offset+1, invovation+" // "+comment)
		edits[lbrace.Filename] = append(edits[lbrace.Filename], delta)
		dirty[lbrace.Filename] = true
		Verbosef("function: %v @ %v\n", fullname, lbrace)
	})

	importStatement := "\n" + `import "` + lc.Import + `"` + "\n"

	locator.WalkFiles(func(filename string,
		pkg *packages.Package,
		comments ast.CommentMap,
		file *ast.File,
		mask locate.HitMask) {
		if !dirty[filename] || ((mask | locate.HasFunction) == 0) {
			return
		}
		if lc.alreadyImported(file, lc.Import) {
			Verbosef("%v: %v: already imported\n", filename, lc.Import)
			return
		}
		_, end := locateutil.ImportBlock(file)
		pos := pkg.Fset.PositionFor(end, false)
		delta := edit.InsertString(pos.Offset, importStatement)
		edits[pos.Filename] = append(edits[pos.Filename], delta)
		Verbosef("import: %v @ %v\n", lc.Import, pos)
	})

	if err := errs.Err(); err != nil {
		return err
	}
	return applyEdits(ctx, edits)
}

const commentTemplateText = `DO NOT EDIT, AUTO GENERATED BY {{.Tag}} {{.Date}}`
const callTemplateText = `
defer {{.Function}}({{.ContextParam}}, "{{.Name}}", "{{.Location}}", {{.Params}})({{.ContextParam}}, {{.Results}})`

var callTemplate = template.Must(template.New("call").Parse(callTemplateText))
var commentTemplate = template.Must(template.New("comment").Parse(commentTemplateText))

func quote(s string) string {
	return `"` + s + `"`
}

func flatten(format string, args []string) string {
	if len(args) == 0 {
		return format
	}
	return format + ", " + strings.Join(args, ", ")
}

func isEmpty(decl *ast.FuncDecl) bool {
	return len(decl.Body.List) == 0
}

func (lc *AddLogCall) alreadyImported(file *ast.File, path string) bool {
	path = `"` + path + `"`
	for _, im := range file.Imports {
		if im.Path.Value == path {
			return true
		}
	}
	return false
}

func (lc *AddLogCall) alreadyAnnotated(fset *token.FileSet, file *ast.File, fn *types.Func, decl *ast.FuncDecl, comment string) bool {
	if isEmpty(decl) {
		return false
	}
	deferStmt, ok := decl.Body.List[0].(*ast.DeferStmt)
	if !ok {
		return false
	}
	cmap := ast.NewCommentMap(fset, file, file.Comments)
	comments := cmap[deferStmt]
	for _, c := range comments {
		if c := c.Text(); strings.HasPrefix(c, comment) {
			return true
		}
	}
	return false
}

func (lc *AddLogCall) annotationForFunc(fset *token.FileSet, fn *types.Func, decl *ast.FuncDecl) (string, string, error) {
	sig := fn.Type().(*types.Signature)
	var ignore []int
	ctxParam, hasContext := annotations.HasCustomContext(sig, lc.ContextType)
	if hasContext {
		ignore = append(ignore, 0)
	}
	params, paramArgs := annotations.ArgsForParams(sig, ignore...)
	results, resultArgs := annotations.ArgsForResults(sig)
	if !hasContext {
		ctxParam = "nil"
	}
	call, comment := &strings.Builder{}, &strings.Builder{}
	pos := fset.Position(decl.Pos())
	parent, base := filepath.Base(filepath.Dir(pos.Filename)), filepath.Base(pos.Filename)
	location := fmt.Sprintf("%s%c%s:%d", parent, filepath.Separator, base, pos.Line)
	lc.ContextParam = ctxParam
	lc.Tag = lc.Type
	lc.Name = fn.Pkg().Path() + "." + fn.Name()
	lc.Location = location
	lc.Params = flatten(quote(params), paramArgs)
	lc.Results = flatten(quote(results), resultArgs)
	lc.Date = time.Now().Format(time.RFC822)
	if err := callTemplate.Execute(call, lc); err != nil {
		return "", "", err
	}
	if err := commentTemplate.Execute(comment, lc); err != nil {
		return "", "", err
	}
	return call.String(), comment.String(), nil
}
